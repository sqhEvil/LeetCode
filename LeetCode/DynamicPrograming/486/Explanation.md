//给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。
//每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。
//给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。



//示例 1：

//输入：[1, 5, 2]
//        输出：False
//        解释：一开始，玩家1可以从1和2中进行选择。
//如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
//所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
//因此，玩家 1 永远不会成为赢家，返回 False 。
//示例 2：

//输入：[1, 5, 233, 7]
//        输出：True
//        解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
//     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。


//提示：
//1 <= 给定的数组长度 <= 20.
//数组里所有分数都为非负数且不会大于 10000000 。
//如果最终两个玩家的分数相等，那么玩家 1 仍为赢家


[1,5,233,7]
所有情形
                           	     [1, 5, 233, 7]
                           	     /		     \								A
                           [5,233,7]	     [1,  5,  233]                        
							/	  \             /      \					B
						[233,7]   [5,233]    [5,233]    [1,5]                    
						/   \      /    \      /    \      /  \				A
				      [7]  [233]  [233]  [5]  [233]  [5]  [5]  [1]          B     

小tip:
 输入数组数量为偶数时，先手可以选择始终拿偶数位，或者始终拿计数位，由于奇数位和偶数位之和总有一个是大于等于另一个。故数组数量位偶数时，先手始终会成为赢家。

解法1（暴力递归 ）：
思路：
1.如上图，循环所有情形。
2.由于题目规定最后得分更多的为赢家，故可以A拿的分数为正，B拿的为负。然后计算所有数加起来的和是否为正数。
3.递归要点：剩余数组起始位置，AB轮换顺序。
4.递归逻辑：分别计算拿左边和拿右边的和，取其中大的。
5.递归结束：数组起始位置合并。
6.递归完成之后，如果计数和大于等于0，则返回true,否则返回false.
代码：
		public bool PredictTheWinner(int[] nums)
        {
            return Loop(nums, 0, nums.Length - 1, 1) >= 0;
        }

        /// <summary>
        /// 计算当前拿法的最优解
        /// </summary>
        /// <param name="nums"></param>
        /// <param name="start">剩余数组坐标开始</param>
        /// <param name="end">剩余数组坐标结束</param>
        /// <param name="turn">轮换标识（1表示A拿，-1表示B拿）</param>
        /// <returns></returns>
        int Loop(int[] nums, int start, int end, int turn)
        {
            if (start == end)
            {
                return nums[start] * turn;
            }
            int left = nums[start] * turn + Loop(nums, start + 1, end, -turn);
            int right = nums[end] * turn + Loop(nums, start, end - 1, -turn);
            return Math.Max(left * turn, right * turn) * turn;//（left*turn是为了和上面的nums[start]*turn抵消，负负得正.）
        }

时间复杂度：O(2^n)


解法2（动态规划）：
思路：
1.


